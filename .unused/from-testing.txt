 Required Changes

  1. Add Timeout to send_and_confirm()

  Replace the infinite loop with a timeout-bound loop (60 seconds max):

  pub async fn send_and_confirm(
      &self,
      rpc_client: &RpcClient,
      commitment_config: CommitmentConfig,
  ) -> Result<Signature, FacilitatorLocalError> {
      let tx_sig = self.send(rpc_client).await?;

      // Add timeout for confirmation (60 seconds)
      let timeout = Duration::from_secs(60);
      let start = std::time::Instant::now();

      loop {
          // Check timeout
          if start.elapsed() > timeout {
              tracing::error!(
                  "Transaction confirmation timeout after 60s. Signature: {}",
                  tx_sig
              );
              tracing::error!("Explorer: https://solscan.io/tx/{}", tx_sig);
              return Err(FacilitatorLocalError::ContractCall(
                  format!(
                      "Transaction {} not confirmed after 60s. Check https://solscan.io/tx/{}",
                      tx_sig, tx_sig
                  )
              ));
          }

          let confirmed = rpc_client
              .confirm_transaction_with_commitment(&tx_sig, commitment_config)
              .await
              .map_err(|e| FacilitatorLocalError::ContractCall(format!("{e}")))?;

          if confirmed.value {
              return Ok(tx_sig);
          }

          tokio::time::sleep(Duration::from_millis(500)).await;
      }
  }

  2. Add Logging to settle() Method (Lines 468-493)

  Add comprehensive logging before and after transaction submission:

  async fn settle(&self, request: &SettleRequest) -> Result<SettleResponse, Self::Error> {
      let verification = self.verify_transfer(request).await?;
      let tx = TransactionInt::new(verification.transaction).sign(&self.keypair)?;

      // Verify if fully signed
      if !tx.is_fully_signed() {
          tracing::event!(Level::WARN, status = "failed", "undersigned transaction");
          return Ok(SettleResponse {
              success: false,
              error_reason: Some(FacilitatorErrorReason::UnexpectedSettleError),
              payer: verification.payer.into(),
              transaction: None,
              network: self.network(),
          });
      }

      // Log transaction submission
      tracing::info!(
          "Submitting Solana transaction for settlement. Network: {}, Payer: {}",
          self.network(),
          verification.payer.pubkey
      );

      // Send and confirm with timeout
      let tx_sig_result = tx
          .send_and_confirm(&self.rpc_client, CommitmentConfig::confirmed())
          .await;

      match tx_sig_result {
          Ok(tx_sig) => {
              tracing::info!(
                  "Transaction confirmed successfully! Signature: {}",
                  tx_sig
              );
              tracing::info!("Explorer: https://solscan.io/tx/{}", tx_sig);

              let settle_response = SettleResponse {
                  success: true,
                  error_reason: None,
                  payer: verification.payer.into(),
                  transaction: Some(TransactionHash::Solana(*tx_sig.as_array())),
                  network: self.network(),
              };
              Ok(settle_response)
          }
          Err(e) => {
              tracing::error!(
                  "Transaction settlement failed. Error: {}",
                  e
              );
              // Return failure response instead of propagating error
              Ok(SettleResponse {
                  success: false,
                  error_reason: Some(FacilitatorErrorReason::UnexpectedSettleError),
                  payer: verification.payer.into(),
                  transaction: None,
                  network: self.network(),
              })
          }
      }
  }

  3. Add Required Imports (Top of File)

  Ensure these imports are present:

  use std::time::{Duration, Instant};
  use tracing_core::Level;